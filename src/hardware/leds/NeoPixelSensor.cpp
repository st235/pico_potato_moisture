#include "./NeoPixelSensor.h"

#include <cmath>
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"

// autogenerated header
#include "ws2812.pio.h"

#define DEFAULT_PIO pio0
#define STATE_MACHINE 0
#define WORKING_FREQ 800000
#define IS_32BIT_ALIGNMENT false

namespace {

inline void PutPixel(uint32_t rgb_pixel) {
    pio_sm_put_blocking(DEFAULT_PIO, 0, rgb_pixel << 8u);
}

} // namespace

namespace hardware {

void ParallelPixelsProcessor() {
    uint32_t rawSelf = multicore_fifo_pop_blocking();
    NeoPixelSensor* self = reinterpret_cast<NeoPixelSensor*>(rawSelf);

    while (true) {
        for (uint32_t i = 0; i < self->size(); i++) {
            PutPixel(self->pixelAt(i));
        }

        sleep_us(400);
    }
}

NeoPixelSensor::NeoPixelSensor(uint8_t pin, uint32_t leds_count, uint32_t starting_led, uint32_t colors[]): _pin(pin), _leds_count(leds_count), _starting_led(starting_led), _colors(colors), _selected_color(0), _active_color(0) {
    uint32_t offset = pio_add_program(DEFAULT_PIO, &ws2812_program);
    ws2812_program_init(DEFAULT_PIO, STATE_MACHINE, offset, pin, WORKING_FREQ, IS_32BIT_ALIGNMENT);

    for(int i = 0; i < size(); i++) {
        PutPixel(0);
    }
}

uint32_t NeoPixelSensor::pixelAt(uint32_t pixel) {
    if (pixel < _starting_led) {
        return 0;
    }

    if (pixel < _starting_led + _active_color) {
        return _colors[_selected_color];
    }

    return 0;
}

uint32_t NeoPixelSensor::size() {
    return _leds_count;
}

void NeoPixelSensor::start() {
    multicore_launch_core1(ParallelPixelsProcessor);
    multicore_fifo_push_blocking(reinterpret_cast<std::uintptr_t>(this));
}

void NeoPixelSensor::setProgress(double progress) {
    uint32_t used_leds = size() - _starting_led;
    uint32_t active_led = used_leds * progress + 0.5 /* round up */;
    _selected_color = active_led;
    _active_color = active_led;
}

} // namespace hardware
